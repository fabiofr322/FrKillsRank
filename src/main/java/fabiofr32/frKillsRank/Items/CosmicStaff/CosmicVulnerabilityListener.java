package fabiofr32.frKillsRank.Items.CosmicStaff;

import fabiofr32.frKillsRank.FrKillsRank;
import org.bukkit.NamespacedKey;
import org.bukkit.Particle;
import org.bukkit.entity.LivingEntity;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.persistence.PersistentDataType;

public class CosmicVulnerabilityListener implements Listener {

    private final NamespacedKey vulnerabilityKey;

    public CosmicVulnerabilityListener(FrKillsRank plugin) {
        this.vulnerabilityKey = new NamespacedKey(plugin, "cosmic_vulnerability");
    }

    @EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
    public void onEntityDamage(EntityDamageByEntityEvent event) {
        if (!(event.getEntity() instanceof LivingEntity target)) {
            return;
        }

        if (!target.getPersistentDataContainer().has(vulnerabilityKey, PersistentDataType.LONG)) {
            return;
        }

        Long expireTime = target.getPersistentDataContainer().get(vulnerabilityKey, PersistentDataType.LONG);
        if (expireTime != null && System.currentTimeMillis() < expireTime) {
            double originalDamage = event.getDamage();
            event.setDamage(originalDamage * 1.25); // Aumenta o dano em 25%

            target.getWorld().spawnParticle(Particle.DAMAGE_INDICATOR, target.getLocation().add(0, 1, 0), (int) (originalDamage / 2) + 1, 0.3, 0.3, 0.3, 0.1);
            target.getWorld().spawnParticle(Particle.CRIT, target.getEyeLocation(), 10, 0.4, 0.4, 0.4, 0.1);

            // Consome a vulnerabilidade apÃ³s o primeiro golpe
            target.getPersistentDataContainer().remove(vulnerabilityKey);

        } else if (expireTime != null) {
            // Se o tempo expirou, remove a tag para limpeza
            target.getPersistentDataContainer().remove(vulnerabilityKey);
        }
    }
}